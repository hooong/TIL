# 객체지향 프로그래밍

### 객체(Object)란?

> - 의사나 행위가 미치는 대상 (사전적 의미)
> - 구체적, 추상적 데이터의 단위 

<br>

### 객체 지향 프로그래밍 (Object Oriented Programming)

> - 객체를 기반으로 하는 프로그래밍
> - 객체를 정의하고, 객체의 기능을 구현하며 객체간의 협력을 구현하는 방식
> - 시간의 흐름에 따르는 절차 지향 프로그래밍과는 다르게 객체간의 연관관계를 생각

<br>

### 클래스 (Class)

> - 객체의 청사진이라 할 수 있다.
> - 멤버 변수와 메서드를 가질 수 있음.

### 메서드 (method)

> - 객체의 기능을 구현하기 위해 클래스 내부에 구현되는 함수
> - 메서드가 곧 객체의 기능이 된다.
> - 메서드의 이름은 사용하는 쪽(클라이언트 코드)에 맞게 명명하는 것이 좋다.

### 인스턴스 

> - 클래스로부터 생성된 객체
> - new 키워드를 통해 생성
> - 멤버변수들이 Heap 메모리에 할당되고 Stack의 변수가 가르키게 됨.
> - java의 가비지 컬렉터가 사용하지 않는 메모리 정리

<br>

### 생성자 (Constructor)

> - 객체를 생성하는 new 키워드와 함께 호출
> - 주로 멤버 변수를 초기화하는 코드를 작성
> - 반환 값이 없고 상속이 되지 않음
> - 생성자의 이름은 클래스의 이름과 동일
> - 이름이 같지만 매개변수가 다른 메서드를 만드는 것을 오버로딩이라 함.



### 접근 제어자 (access modifier)

> - 변수, 메서드, 생성자에 대한 접근 권한 지정

### 정보 은닉 (information hiding)

> - 외부에서 클래스 내부의 정보에 접근하지 못하도록 함
> - 따라서 클래스 내부 데이터를 잘못 사용하여 발생하는 오류를 방지



### static 메서드 == class 메서드

> - static 메서드 안에서 인스턴스 변수는 사용불가.
> - 반대로 static 변수는 class가 load될 때 생성되므로 아무곳에서나 사용가능.



### Singleton pattern

> - 단 하나만 존재하는 인스턴스
> - 생성자는 private으로 static을 사용해 유일한 객체 생성
> - 외부에서 유일한 객체를 참조할 수 있는 public static get() 메서드 구현
> - Ex) java.util.Calendar를 new로 만들 수 없음. => Calendar.getInstance();



#### System.arraycopy(src, srcpos, dest, despots, length)

> - 얕은복사 



### ArrayList

> - 자바에서 제공되는 객체 배열이 구현된 클래스
> - 주요메서드
>   - Boolean add(E e) : 요소 하나를 배열에 추가
>   - int size() : 배열의 요소 전체 개수
>   - E get(int index) : index 위치의 요소 값 반환
>   - E remove(int index) : index 위치의 요소 제거하고 값 반환
>   - Boolean isEmpty() : 비어있는지 확인



### 상속

> - 하위클래스가 생성되기 전에 무조건 상위클래스가 생성된다.
> - 상위클래스의 타입으로 선언 가능 (업캐스팅) => 묵시적으로 형변환.
> - 하위클래스로의 형 변환은 명시적이어야 함.



### 가상 메서드 (virtual method)

> - 메서드의 이름과 메서드 주소를 가진 가상 메서드 테이블에서 호출될 메서드의 주소를 참조.
> - 상위 클래스의 메서드를 오버라이딩하고 상위클래스 타입으로 선언하고 재정의된 메서드를 사용하면 하위클래스에서 오버라이딩 되어진 메서드가 호출 됨.



### 다형성 (Polymorphism)

> - 하나의 코드가 여러 자료형으로 구현되어 실행되는 것.
> - 불필요한 if문을 줄일 수 있다.



### 추상 클래스(abstract)

> - 추상 메서드를 포함한 클래스
> - 추상 메서드 - 구현 코드가 없이 선언부만 있는 메서드
> - 추상 클래스는 new 키워드를 사용할 수 없음. => 인스턴스화 불가능



### 템플릿 메서드

> - 추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의해 놓은 메서드
> - final로 선언하여 재정의 할 수 없게 함.



### 인터페이스

> - 역할 : 클라이언트 프로그램에 어떤 메서드를 제공하는지 알려주는 명세(specification)
> - 인터페이스의 요소
>   - 추상 메서드
>   - 상수
>   - 디폴트 메서드 : 기본 구현을 가지는 메서드, 오버라이딩 가능
>   - 정적 메서드 : 인스턴스 생성과 상권없이 인터페이스 타입으로 호출하는 메서드
>   - private 메서드 : 인터페이스 내(디폴트, 정적)에서 사용하기 위해 구현한 메서드
> - 인터페이스에서 선언한 변수는 컴파일 과정에서 상수로 변환됨.(public static final이 붙음.)
> - 인터페이스에서 선언한 메서드는 컴파일 과정에서 추상 메서드로 변환됨.
> - 인터페이스를 구현한 클래스는 인터페이스 타입으로 변수를 선언하여 인스턴스를 생성할 수 있다.
> - 인터페이스는 타입 상속이라 한다.
> - 하나의 클래스가 여러 인터페이스를 구현할 수 있음
>   - 디폴트 메서드의 이름이 중복되는 경우에는 재정의 한다.
> - 인터페이스 간에도 상속이 가능하다
> - 클래스 구현시 인터페이스 구현과 상속을 함께 사용할 수 있다.



### Object 클래스

> - 모든 클래스의 최상위 클래스
> - Java.lng.Object 클래스
> - 모든 클래스는 Object 클래스에서 상속받음
> - 모든 클래스는 Object 클래스의 메서드를 사용할 수 있음
> - 모든 클래스는 Object 클래스의 일부 메서드를 재정의하여 사용할 수 있음
>   - => 일부인 이유는  final로 선언된 메서드가 있기 때문.



### toString() 메서드

> - Object의 toString() 메서드를 오버라이딩하여 원하는 출력을 만들 수 있음.



### equals() 메서드

> - 두 객체의 동일함을 논리적으로 재정의 할 수 있음
> - 물리적 : 같은 주소를 가지는 객체
> - 논리적 : 같은 학번의 학생, 같은 주문 번호의 주문 등



### hashCode() 메서드

> - 반환값 : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환
> - 객체에서 hashCode()를 구분할 수 있는 변수로 지정한다.
> - 실제 주소를 받기위해서는 `System.*identityHashCode*(i1)`를 사용.



### clone() 메서드

> - 객체의 복사본을 만든다.
> - 객체지향 프로그래밍의 정보은닉에 위배되는 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 함.



### finalize() 메서드

> - 객체가 heap영역에서 해제될 때 가비지 컬렉터에 의해서 수행되는 코드



### ,Class 클래스

> - 자바의 모든 클래스와 인터페이스는 컴파일 후 class파일로 생성된다.
> - class 파일에는 객체의 정보(멤버변수, 메서드, 생성자 등)이 포함되어있다.
> - Class 클래스는 컴파일 된 class파일에서 객체의 정보를 가져올 수 있다.
> - reflection 프로그래밍
>   - Class 클래스로부터 객체의 정보를 가져와 프로그래밍 하는 방식
>   - 로컬에 객체가 없고 자료형을 알 수 없는 경우 유용한 프로그래밍 방식
>   - Java.lang.reflect 패키지에 있는 클래스 활용



### forName() 메서드와 동적 로딩

> - Class 클래스 static메서드
> - 동적 로딩이란? 컴파일시에 데이터 타입이 모두 binding되어 자료형이 로딩되는 것(static loding)이 아니라 실행 중에 데이터 타입을 아로고 binding되는 방식
> - 실행 시에 로딩되므로 경우에 따라 다른 클래스가 사용될 수 있어 유용함





