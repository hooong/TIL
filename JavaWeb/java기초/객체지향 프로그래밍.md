# 객체지향 프로그래밍

### 객체(Object)란?

> - 의사나 행위가 미치는 대상 (사전적 의미)
> - 구체적, 추상적 데이터의 단위 

<br>

### 객체 지향 프로그래밍 (Object Oriented Programming)

> - 객체를 기반으로 하는 프로그래밍
> - 객체를 정의하고, 객체의 기능을 구현하며 객체간의 협력을 구현하는 방식
> - 시간의 흐름에 따르는 절차 지향 프로그래밍과는 다르게 객체간의 연관관계를 생각

<br>

### 클래스 (Class)

> - 객체의 청사진이라 할 수 있다.
> - 멤버 변수와 메서드를 가질 수 있음.

### 메서드 (method)

> - 객체의 기능을 구현하기 위해 클래스 내부에 구현되는 함수
> - 메서드가 곧 객체의 기능이 된다.
> - 메서드의 이름은 사용하는 쪽(클라이언트 코드)에 맞게 명명하는 것이 좋다.

### 인스턴스 

> - 클래스로부터 생성된 객체
> - new 키워드를 통해 생성
> - 멤버변수들이 Heap 메모리에 할당되고 Stack의 변수가 가르키게 됨.
> - java의 가비지 컬렉터가 사용하지 않는 메모리 정리

<br>

### 생성자 (Constructor)

> - 객체를 생성하는 new 키워드와 함께 호출
> - 주로 멤버 변수를 초기화하는 코드를 작성
> - 반환 값이 없고 상속이 되지 않음
> - 생성자의 이름은 클래스의 이름과 동일
> - 이름이 같지만 매개변수가 다른 메서드를 만드는 것을 오버로딩이라 함.



### 접근 제어자 (access modifier)

> - 변수, 메서드, 생성자에 대한 접근 권한 지정

### 정보 은닉 (information hiding)

> - 외부에서 클래스 내부의 정보에 접근하지 못하도록 함
> - 따라서 클래스 내부 데이터를 잘못 사용하여 발생하는 오류를 방지



### static 메서드 == class 메서드

> - static 메서드 안에서 인스턴스 변수는 사용불가.
> - 반대로 static 변수는 class가 load될 때 생성되므로 아무곳에서나 사용가능.



### Singleton pattern

> - 단 하나만 존재하는 인스턴스
> - 생성자는 private으로 static을 사용해 유일한 객체 생성
> - 외부에서 유일한 객체를 참조할 수 있는 public static get() 메서드 구현
> - Ex) java.util.Calendar를 new로 만들 수 없음. => Calendar.getInstance();



#### System.arraycopy(src, srcpos, dest, despots, length)

> - 얕은복사 



### ArrayList

> - 자바에서 제공되는 객체 배열이 구현된 클래스
> - 주요메서드
>   - Boolean add(E e) : 요소 하나를 배열에 추가
>   - int size() : 배열의 요소 전체 개수
>   - E get(int index) : index 위치의 요소 값 반환
>   - E remove(int index) : index 위치의 요소 제거하고 값 반환
>   - Boolean isEmpty() : 비어있는지 확인



### 상속

> - 하위클래스가 생성되기 전에 무조건 상위클래스가 생성된다.
> - 상위클래스의 타입으로 선언 가능 (업캐스팅) => 묵시적으로 형변환.
> - 하위클래스로의 형 변환은 명시적이어야 함.



### 가상 메서드 (virtual method)

> - 메서드의 이름과 메서드 주소를 가진 가상 메서드 테이블에서 호출될 메서드의 주소를 참조.
> - 상위 클래스의 메서드를 오버라이딩하고 상위클래스 타입으로 선언하고 재정의된 메서드를 사용하면 하위클래스에서 오버라이딩 되어진 메서드가 호출 됨.



### 다형성 (Polymorphism)

> - 하나의 코드가 여러 자료형으로 구현되어 실행되는 것.
> - 불필요한 if문을 줄일 수 있다.



### 추상 클래스(abstract)

> - 추상 메서드를 포함한 클래스
> - 추상 메서드 - 구현 코드가 없이 선언부만 있는 메서드
> - 추상 클래스는 new 키워드를 사용할 수 없음. => 인스턴스화 불가능



### 템플릿 메서드

> - 추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의해 놓은 메서드
> - final로 선언하여 재정의 할 수 없게 함.



### 인터페이스

> - 역할 : 클라이언트 프로그램에 어떤 메서드를 제공하는지 알려주는 명세(specification)
> - 인터페이스의 요소
>   - 추상 메서드
>   - 상수
>   - 디폴트 메서드 : 기본 구현을 가지는 메서드, 오버라이딩 가능
>   - 정적 메서드 : 인스턴스 생성과 상권없이 인터페이스 타입으로 호출하는 메서드
>   - private 메서드 : 인터페이스 내(디폴트, 정적)에서 사용하기 위해 구현한 메서드
> - 인터페이스에서 선언한 변수는 컴파일 과정에서 상수로 변환됨.(public static final이 붙음.)
> - 인터페이스에서 선언한 메서드는 컴파일 과정에서 추상 메서드로 변환됨.
> - 인터페이스를 구현한 클래스는 인터페이스 타입으로 변수를 선언하여 인스턴스를 생성할 수 있다.
> - 인터페이스는 타입 상속이라 한다.
> - 하나의 클래스가 여러 인터페이스를 구현할 수 있음
>   - 디폴트 메서드의 이름이 중복되는 경우에는 재정의 한다.
> - 인터페이스 간에도 상속이 가능하다
> - 클래스 구현시 인터페이스 구현과 상속을 함께 사용할 수 있다.



### Object 클래스

> - 모든 클래스의 최상위 클래스
> - Java.lng.Object 클래스
> - 모든 클래스는 Object 클래스에서 상속받음
> - 모든 클래스는 Object 클래스의 메서드를 사용할 수 있음
> - 모든 클래스는 Object 클래스의 일부 메서드를 재정의하여 사용할 수 있음
>   - => 일부인 이유는  final로 선언된 메서드가 있기 때문.



### toString() 메서드

> - Object의 toString() 메서드를 오버라이딩하여 원하는 출력을 만들 수 있음.



### equals() 메서드

> - 두 객체의 동일함을 논리적으로 재정의 할 수 있음
> - 물리적 : 같은 주소를 가지는 객체
> - 논리적 : 같은 학번의 학생, 같은 주문 번호의 주문 등



### hashCode() 메서드

> - 반환값 : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환
> - 객체에서 hashCode()를 구분할 수 있는 변수로 지정한다.
> - 실제 주소를 받기위해서는 `System.*identityHashCode*(i1)`를 사용.



### clone() 메서드

> - 객체의 복사본을 만든다.
> - 객체지향 프로그래밍의 정보은닉에 위배되는 가능성이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 함.



### finalize() 메서드

> - 객체가 heap영역에서 해제될 때 가비지 컬렉터에 의해서 수행되는 코드



### ,Class 클래스

> - 자바의 모든 클래스와 인터페이스는 컴파일 후 class파일로 생성된다.
> - class 파일에는 객체의 정보(멤버변수, 메서드, 생성자 등)이 포함되어있다.
> - Class 클래스는 컴파일 된 class파일에서 객체의 정보를 가져올 수 있다.
> - reflection 프로그래밍
>   - Class 클래스로부터 객체의 정보를 가져와 프로그래밍 하는 방식
>   - 로컬에 객체가 없고 자료형을 알 수 없는 경우 유용한 프로그래밍 방식
>   - Java.lang.reflect 패키지에 있는 클래스 활용



### forName() 메서드와 동적 로딩

> - Class 클래스 static메서드
> - 동적 로딩이란? 컴파일시에 데이터 타입이 모두 binding되어 자료형이 로딩되는 것(static loding)이 아니라 실행 중에 데이터 타입을 아로고 binding되는 방식
> - 실행 시에 로딩되므로 경우에 따라 다른 클래스가 사용될 수 있어 유용함



### String

- `String s1 = new String("abc")` => 인스턴스 생성.

- `String s2 = "abc"` => 상수풀에서 값을 가져옴.
- String은 immutable하다. => 한번 선언되거나 생성된 문자열을 변경할 수 없다.
- concat()을 하고나면 새로운 메모리 주소를 가르켜 메모리 낭비를 일으킬 수 있다.



### StringBuilder, StringBuffer

- mutable하다. => 문자열을 변경할 수 있다.
- StringBuilder은 멀티쓰래드 프로그래밍에서 동기화가 안된다.



### 제네릭 프로그래밍

> - 변수의 선언이나 메서드의 매개변수를 하나의 참조 자료형이 아닌 여러 자료형으로 변환될 수 있도록 프로그래밍 하는 방식



### 컬렉션 프레임워크

> - 프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리
> - Java.util 패키지에 구현되어 있다.
> - Collection  인터페이스와 Map 인터페이스로 구성되어 있다.
> - Collection
>   - List : 순서가 있는 자료 관리 / 중복 허용
>     - ArrayList, Vector, LinkedList
>     - Vector는 동기화를 지원하여 멀티 쓰레드 프로그래밍에서 사용하면 좋음
>   - Set : 순서가 정해져 있지 않음 / 중복 허용 X
>     - HashSet, TreeSet
>     - HashSet을 사용할때 String은 중복 키값을 막는 것이 구현되어있지만 그 외의 객체는 equals()와 hashCode()를 원하는 키값에 맞게 오버라이딩하여 사용해야 중복을 막을 수 있다.
>     - TreeSet : 중복을 허용하지 않으면서 오름차순이나 내림차순으로 객체를 정렬
>       - binary search tree로 구현되어 있다.
>       - 객체 비교를 위해서는 Comparable이나 Comparator 인터페이스를 구현해야 한다.
>       - Comparator를 사용할때는 TreeSet을 new할때 Comparator가 구현되어있는 class를 매개변수에 인스턴스로 생성해주어야한다.
>   - iterator() : Collection의 개체를 순회하는 인터페이스
>     - get(i) 메서드가 제공되지 않는 Set의 중복이 허용되지 않는 구조에서 유용.
> - Map
>   - Key-value쌍으로 되어있는 구조
>     - Hashtable, HashMap, TreeMap
>       - HashTable이 동기화 지원
>     - HashMap
>       - put : 추가
>       - remove : 삭제
>       - containKey, containValue : 특정 키 및 값이 있는지 확인
>       - keySet() : key는 중복이 허용되지 않으므로 Set으로 반환
>       - values() : value는 중복이 허용되므로 collection으로 반환된다.
>       - 기존 정의된 자료구조가 아닌 객체를 비교할때는 equals(), hashCode() 재정의 해야함.



### 내부 클래스

> - 클래스 내부에 구현한 클래스
> - 클래스 내부에서 사용하기 위해 선언하고 구현하는 클래스
> - 주로 외부 클래스 생성자에서 내부 클래스를 생성
> - 인스턴스 내부 클래스, 정적 내부 클래스, 지역 내부 클래스, 익명 내부 클래스



### 람다식

> - 자바에서 함수형 프로그래밍을 구현하는 방식
>   - 함수형 프로그래밍이란?
>     - 매개변수만을 사용하도록 만든 함수로 외부 자료에 부수적인 영향이 발생하지 않도록 함
>     - 외부에 영향을 미치지 않아 병렬처리 같은 곳에 사용가능하고 안정적인 확장성있는 프로그래밍 방식.
> - 클래스를 생성하지 않고 함수의 호출만으로 기능을 수행
> - @FunctionalInterface가 달린 인터페이스를 구현하고 사용하여야함.



### 스트림 (Stream)

> - 자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능 ( 자료의 추상화 )
> - 중간연산과 최종연산으로 나뉨
>   - 중간연산 : filter(), map() 등...
>   - 최종연산 : forEach(), count(), sum() 등...



### 오류

> - 컴파일 오류 : 프로그램 코드 작성 중 발생하는 문법적 오류
> - 실행 오류 : 실행중인 프로그램이 의도하지 않은 동작(bug)을 하거나 프로그램이 중지되는 오류(runtime error)
> - 시스템 오류(error) : 가상 머신에서 발생, 프로그래머가 처리할 수 없다.
>   - 동적메모리를 다 사용한 경우
>   - 스택오버플로우...
> - 예외 (Exception) : 프로그램에서 제어할 수 있는 오류
>   - 읽으려는 파일이 없는 경우
>   - 네트워크이나 소켓 연결 오류...
>   - 자바는 예외 클래스에서 예외에 대한 처리를 해준다.



### Try-catch

> - 프로그램 종료없이 예외를 처리하기 위한 구문



### Try-with-resource

> - Finally를 생략할 수 있게 만들어줌
> - AutoCloseable를 구현하면 자동으로 close()되게 만들 수 있음.



### 입출력 스트림 (위의 스트림과는 다름)

> - 다양한 입출력 장치에 독립적으로 일관성있는 입출력 방식 제공
> - 입출력 스트림의 구분
>   - I/O 대상 기준 : 입력 스트림, 출력 스트림
>   - 자료의 종류 : 바이트 스트림(stream이 붙음), 문자 스트림(reader, writer가 붙음)
>   - 스트림의 기능 : 기반 스트림, 보조 스트림
>     - 기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림
>     - 보조 스트림 : 직접 읽고쓰는 기능은 없고 추가적인 기능을 제공해주는 스트림



### 바이트 단위 스트림

> - InputStream : 바이트 단위 입력 스트림 최상위 클래스
> - OutputStream : 바이트 단위 출력 스트림 최상위 클래스
> - FileInputStream, FileOutputStream 
>   - 파일을 한 바이트씩 읽고 쓰는데 사용
>   - 입력 스트림은 파일이 없는 경우 예외 발생
>   - 출력 스트림은 파일이 없는 경우 파일 생성하여 출력



### 문자 단위 스트림

> - Reader : 문자 단위로 읽는 최상위 스트림
> - Writer : 문자 단위로 쓰는 최상위 스트림
> - 한글 문자를 읽기위해서는 Reader를 사용해야함. 
>   - 바이트 단위로 한글을 읽으면 다 깨짐.
>   - 이미 바이트로 읽었다면 InputStreamReader를 사용하여 문자 단위로 다시 읽음.



### 보조 스트림

> - 실제 읽고 쓰는 스트림이 아닌 보조적인 기능을 추가하는 스트림
> - 생성자의 매개변수로 또 다른 스트림을 가진다.
> - 데코레이터 패턴 (Decorator Pattern)
> - 보조 스트림에 보조 스트림을 넣을 수도 있다.
> - InputStreamReader, BufferedReader...
> - DataInputStream, DataOutputStream