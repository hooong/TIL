# Network

Tcp 흐름, 혼잡, 에러제어

----

## DNS
네트워크상에서 컴퓨터를 식별하는 호스트명

## DNS Server
IP주소와 도메인의 매핑 정보를 관리하면서 도메인 or IP주소를 묻는 요청이 올 경우 이에 응답하는 서버.
- 모든 인터넷 트래픽을 한 곳에서 담당할 수 없어 계층 형태로 분산시킴
	- 루트 DNS 서버
	- 최상위 레벨 도메인 DNS 서버 (TLD)
	- 책임 DNS 서버
- Iterative Queries
	1. 로컬 DNS 서버로 쿼리를 보냄 -> cache를 살펴보고 없다면 다음 단계로 진행
	2. Root Name server로 쿼리를 보냄 -> TLD 서버 정보 제공
	3. TLD name server로 쿼리를 보냄
	4. 여러번의 질의를 통해 타겟 ip 주소를 알아냄 -> 접속

## DHCP
호스트의 IP주소 및 TCP/IP설정을 클라이언트에 자동으로 제공하는 프로토콜
- 자신의 IP주소, 가장 가까운 라우터의 IP주소, 가장 가까운 DNS서버의 IP주소를 받음.
- 이후 ARP 프로토콜을 이용해 IP주소를 기반으로 가장 가까운 라우터의 MAC주소를 알아냄.

----

## HTTP (Hyper Text Transfer Protocol)

http는 이름 그대로 하이퍼텍스트 문서를 주고받는데 사용하는 통신 규약이다. 즉, 웹 서버와 클라이언트 간의 통신을 하기 위한 통신 규약이라고도 할 수 있다.

### 특징

- TCP/IP를 사용하는 Application protocol
- 연결 상태를 유지하지 않는 비연결성 프로토콜 (이러한 단점을 해결하기 위해 cookie와 session 등장)
- HTTP 1.1에서 keep-alive를 설정하면 커넥션 유지가 가능하긴 함.
- 요청과 응답 방식으로 동작
- Json 및 Xml과 같은 형태의 정보도 주고 받을 수 있음.



## TLS (Transport Layer Security)

인터넷 상에서의 정보를 암호화해서 송수신하는 Application Layer의 프로토콜.

SSL에 기반한 기술로, SSL의 취약점으로 인해 개발됨.



## HTTPS (HTTP over Secure)

과거 SSL을 사용했지만 현재는 TLS를 사용해 암호화된 연결을 하는 HTTP를 HTTPS라고 한다.

- HTTP에서 보안이 강화된 버전이라 할 수 있음.
- 브라우저는 이미 인증기관 목록을 가지고 있다.



## Cookie

웹 서버가 브라우저에게 지시하여 사용자의 로컬 컴퓨터에 파일 또는 메모리에 저장하는 기록 파일.

- 정보를 유지할 수 없는(Connectionless, Stateless) HTTP의 단점을 해결하기 위해 도입
- 파일에 담긴 정보는 같은 웹사이트를 방문할 때마다 읽히고 수시로 새로운 정보로 바뀔 수 있다.

### 구성요소

- Name : 쿠키의 이름
- Value : 저장된 값
- Exprires : 쿠키의 만료 시점을 결정
- Domain : 사용되는 도메인
- Path : 쿠키를 반환할 경로를 결정
- Secure : 보안 연결 설정
- HttpOnly : HTTP외에 다른 통신 사용 가능 설정

### 종류

- Session Cookie : 보통 만료시간이 설정되고 메모리에만 저장되어 브라우저 종료 시 쿠키 삭제
- Persistent Cookie : 장기간 유지되는 쿠키로 파일로 저장되어 브라우저 종료 시에도 삭제되지 않음
- Secure Cookie : 암호화된 정보를 담고있는 쿠키, HTTPS에서만 사용
- Third-Party Cookie : 방문한 도메인과 다른 도메인의 쿠키, 보통 광고, 배너 등을 관리할 때 유입 경로를 추적하기 위해 사용.

### 단점

- 매 요청마다 쿠키에 대한 정보를 헤더에 담아 보내 상당한 트래픽을 발생시킴.
- 쿠키가 유출되면 보안에 대한 문제가 발생할 수 있음.



## Session

쿠키의 트래픽, 보안 이슈를 해결하기 위해 등장하였고, 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술이다.

- HTTP Session id를 식별자로 구분하여 데이터를 사용자의 브라우저에 쿠키형태가 아닌 접속한 서버 DB에 정보를 저장.
- 클라이언트는 Session id를 쿠키의 형태로 메모리에 저장
- 쿠키를 메모리에 저장하므로 브라우저 종료 시 사라짐.

### 세션 절차

1. 클라이언트가 서버에 Request을 보냄.
2. 서버는 Request의 쿠키에서 Session id를 확인 후 없으면 Set-Cookie를 통해 새로 발행한 Session id를 보냄
3. 이후 클라이언트는 Session id를 포함하여 Request를 보냄
4. 서버는 Session id를 통해 해당 세션을 찾고 클라이언트의 상태 정보를 유지하며 적절한 응답.

### 서버 입장에서의 Session

#### 장점

- 서버에 저장하여 관리가 편하고 효율적

#### 단점

- Load-balancing / 시스템 효율성에서 handling하기 어려움
- 세션 저장 장치가 부족한 시스템에서는 부적합.

#### 해결책

- Load-balancing 문제
  - 세션 정보를 하나의 저장장치에 공유
  - 각각의 클라이언트를 다른 서버에 바인딩
- 저장 장치
  - 메모리 기반의 저장 장치 사용

세션의 내용이 서버에 저장되기 때문에 session이 늘어날수록 서버에는 부하가 걸리게 된다.



## Cookie와 Session의 차이점

- 쿠키는 클라이언트의 로컬에 세션은 클라이언트와 서버에 모두 저장된다.
- 쿠키는 탈취와 변조가 가능하여 세션보다 보안이 좋지 않다.
- 쿠키는 브라우저가 종료되도 파일로 남지만 세션은 브라우저 종료시 삭제가 됨.
- 세션은 요청마다 서버에서 처리를 거치므로 쿠키에 비해 느리다.

----

## 3way-Handshake

양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제 데이터 전달이 시작하기전에 한쪽이 다른 쪽이 준비되어 있다는 걸을 알 수 있도록한다.

- 2 Way의 문제점

  1. A가 B에게 SYN을 보냄
  2. B가 A에게 ACK를 보냄

  3. A에서 Time out이 발생하여 B에게 SYN 재전송
  4. 2번에서 보낸 ACK를 A가 받음 -> data 전송
  5. 3번에서 보낸 SYN을 B가 받고 ACK를 받음.
  6. 5번의 ACK를 받고 4번에서와 동일한 data 전송

  -> 의도지 않게 재전송들이 발생하게 된다.

Quic
Ns-3

#CS