# Algorithm

----

## Sorting

### 선택 정렬

현재 위치 이후의 값들 중 최솟값 또는 최댓값을 찾아 교체하는 정렬 알고리즘으로 앞쪽에서부터 정렬이 되어나감.

#### 시간 복잡도 

- O(N^2) -> 이중for문

#### 공간 복잡도

- O(N) -> 주어진 배열 안에서만 교환이 이루어짐.

#### 장점

- 구현이 간단

#### 단점

- 시간 복잡도가 크기때문에 비효율적
- 불안정 정렬이다.



### 버블 정렬

서로 인접한 두 원소를 검사하여 정렬하는 알고리즘으로 뒤쪽에서부터 정렬이 되어나간다.

#### 시간 복잡도

- O(N^2)

#### 공간 복잡도

- O(N) -> 선택 정렬과 마찬가지

#### 장점

- 구현이 간단
- 안정 정렬이다. (이미 정렬되어있는 원소들의 순서가 유지됨.)

#### 단점

- 시간 복잡도가 최악, 최선 모두 O(N^2)으로 비효율적이다.
- 교환 횟수가 많다
- 배열이 역순으로 정렬이 되어있을 경우 아주 느리다.



### 삽입 정렬

1번째 인덱스의 원소를 시작으로 해당 원소 앞쪽의 원소들과 비교하여 위치를 찾아 삽입하는 정렬 알고리즘

#### 시간 복잡도

- 평균 및 최악의 경우(역순으로 정렬) : O(N^2)
- 최선의 경우(정렬이 되어있는 경우) : O(N)

#### 공간 복잡도

- O(N)

#### 장점

- 대부분의 원소가 이미 정렬되어 있는 경우 매우 효율적이다.
- 선택 정렬이나 버블 정렬에 비해 빠르다.

#### 단점

- 비교할 수가 많을 경우에 적합하지 않음.
- 평균이 O(N^2)으로 비효율적이다.



### 병합 정렬

분할 정복을 통하여 배열을 쪼개고 다시 병합하면서 정렬해나가는 정렬 알고리즘

#### 시간 복잡도

- O(NlogN)

#### 공간 복잡도

- O(N) + O(logN) -> 병합과정에서 임시배열이 필요함.

#### 장점

- 입력 데이터가 무엇이든 간에 정렬되는 시간이 동일
- 안정정렬

#### 단점

- 임시 배열이 필요할 수 있다.



### 퀵 정렬

pivot을 기준으로 pivot보다 작은 요소와 큰 요소들을 나누고 분할정복을 통해 정렬을 해나가는 알고리즘

또한, pivot을 해당 데이터에서 중간값을 고를수록 성능이 개선될 수 있다.

#### 시간 복잡도

- 최선의 경우 : O(NlogN)
- 최악의 경우 : O(N^2)

#### 공간 복잡도

- O(N)

#### 장점

- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에 시간 복잡도가 O(NlogN)을 가지는 다른 정렬들에 비해 빠르다.
- 병합 정렬과 다르게 다른 메모리 공간을 필요로 하지 않는다.

#### 단점

- 불안정 정렬
- 정렬된 배열에서 Quick Sort의 불균형 분할에 의해 오히려 수행 시간이 더 많이 걸린다.



### 힙 정렬

완전 이진 트리를 기본으로 하는 힙 자료구조를 기반으로 한 알고리즘으로 최대힙, 최소힙이 있을 수 있다.

#### 최대힙에서의 삽입

1. 삽입하려는 요소를 힙의 마지막 노드에 이어서 삽입
2. 해당 요소를 부모와 비교를 하면서 크다면 교환
3. 부모의 값보다 작을때까지 2번을 반복

#### 최대힙에서의 삭제

1. 힙의 마지막 노드를 루트로 설정
2. 자식들과 비교하여 작다면 교환 자식들 중 큰 값과 교환
3. 모든 자식들보다 클 경우까지 2번을 반복

#### 시간 복잡도

- O(NlogN)

#### 장점

- 전체 자료를 정렬해야하는 경우보다 최댓값이나 최솟값의 몇개를 사용할때 효율적

----

## Tree

- 비선형구조
- 계층적 관계
- 그래프와 달리 사이클이 존재하지 않음
- 루트 노드를 제외한 모든 노드는 단 하나의 부모 노드를 가짐.



