# Web

## GET, POST
GET은 가져오는 것이고, POST는 수행하는 것이다.
### GET

- 데이터가 URL 뒤에 붙어 보내진다.
- select 성격을 가진다. 
- POST에 비해 전송할 수 있는 데이터의 양이 적다.

### POST

- 데이터가 body에 담겨 보내진다.
- 서버의 값이나 상태를 바꾸기위해서 사용된다.

----

## 대칭키
A와 B가 서로 같은 키를 가지고 암호화, 복호화 진행

### 장점

- 공개키 방식보다 암호화, 복호화가 간단하여 빠르다.

### 단점

- 대칭키를 공유해야하는데 전달하는 과정에서 해킹의 위험에 노출될 수 있음.

## 공개키
암호화와 복호화에 사용되는 키를 분리한 방식으로 외부에 공개키를 주고 공개키로 암호화 된 문서를 자신의 private key로 복호화.
크게 두 가지로 나뉨
- 공개 키 암호 - 특정한 비밀 키를 가지고 있는 사용자만 내용을 열어볼 수 있음.(편지 넣는 투입구가 있는 우편함)
	- 공개키를 가지고 암호화 개인키를 가지고 복호화
![](Web/IMG_A1483E0656EE-1.jpeg)
- 공개 키 서명 - 특정한 비밀 키로 만들어졌다는 것을 누구나 확인할 수 있음. (인장으로 편재봉투를 봉한 것)
	- 개인키로 암호화 -> 공개키로 복호화
	- 이는 데이터의 보호의 목적보다는 데이터 제공자의 신원 확인이 보장된다는 것에 초점이 맞음.

### 단점

- 암복호화가 매우 복잡하다 (왜? 암호화와 복호화 키가 서로 다르니까)

## 대칭키 & 공개키 통합 암호화 방식
대칭키와 공개키를 적절히 혼합한 암호화 방식으로 SSL의 시초가 되었음.
```
1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하여 B에게 송신
2. B는 암호문을 받아, 자신의 비밀키로 복호화
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄.
4. A는 자신의 대칭키로 암호문을 복호화
5. 이후부터는 대칭키로 암호화 통신
```

## SSL (Secure Socket Layer)
넷스케이프사에서 전자상거래보안을 위해 개발한 암호화 방식으로 통신하는 상대방이 해커가 아닌지 확인하기 위한 알고리즘
```
1. 사이트는 인증기관에 자신의 정보와 공개키를 제출
2. 인증기관이 검토하고 자신의 개인키로 암호화하여 인증서 생성
3. 2번에서 암호화 된 인증서를 사이트로 송신
4. 개인이 브라우저를 통해 사이트에 접속하면, 암호화된 사이트의 정보와 공개키를 사이트로부터 받음
5. 브라우저가 인증기관의 공개키(브라우저에게만 공개됨)로 이를 복호화 하여 사이트의 공개키를 얻음
6. 브라우저가 대칭키를 사이트의 공개키로 암호화하여 사이트로 보냄
7. 사이트는 자신의 개인키로 암호화 된 대칭키를 복호화
8. 이제 개인과 사이트는 대칭키로 통신 가능
```

- - - -

## 웹 서버
- Client의 요청과 접속관리를 주관
- HTTP를 통해 웹 브라우저에서 요청하는 HTML문서나 오브젝트(이미지 파일 등)을 전송해주는 서비스 프로그램 
- ex) apache, nginx

## WAS (Web Application Server)
- 웹 애플리케이션의 사용자가 많아져 웹서버에 과부하(클라이언트마다 각각의 프로세스를 할당)가 걸리기 시작하자 WAS가 등장.
- 실질적인 애플리케이션 실행(비즈니스 로직, DB접근)을 주관
- 클라이언트의 접속관리와 앱 실행을 분리함으로써 여러 클라이언트가 접근해도 비즈니스 로직 처리를 쓰레드로 할 수 있어짐.
- ex) tomcat

----

## JWT (Json Web Token)

Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token

- 토큰 자체를 정보로 사용하는 Self-Contained 방식

### JWT의 구조

JWT는 `Header.Payload.Signature`의 구조로 이루어져 있으며, 각 부분은 json형태가 Base64로 인코딩되어 표현되어있다.

- Header

  - typ와 alg로 이루어짐.

  - typ : 토큰의 타입을 지정
    - Ex) JWT
  - alg : 서명(Signature) 및 토큰 검증에 사용하는 알고리즘 방식 지정
    - Ex) HS256, RSA

- Payload

  - 토큰에서 사용할 정보의 조각들인 Claim이 담겨있다.
  - 각 클래임은 json의 형태인 key-value형태로 다수의 정보를 넣을 수 있다.

- Signature

  - 토큰을 인코딩하거나 유효성 검증을 할때 사용하는 고유한 암호화 코드

### 단점 및 고려사항

- Self-contained : 토큰 자체에 정보를 담고 있어 혹시라도 보안 문제가 생길 수 있음.
- 토큰의 페이로드에 정보가 많아질수록 토큰의 길이가 늘어나 상당한 트래픽이 발생할 수 있음
- stateless : jwt는 상태를 저장하지 않고 한번 만들어지면 제어가 불가능하므로 토큰 만료 시간을 꼭 넣어주어야함.

----

## REST

- "Representational State Transfer"의 약자

- 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미

- 즉, 자원(resource)의 표현(representation)에 의한 상태 전달

  - 자원 : 해당 프로그램이 관리하는 모든 것
  - 자원의 표현 : 그 자원을 표현하기 위한 이름

  - 상태 전달 
    - 데이터가 요청되어지는 시점에서의 자원의 상태를 전달
    - 보통 JSON 혹은 XML을 통해 주고 받음.

- HTTP Method를 통해 자원에 대한 CRUD를 적용

  - GET : Read
  - POST : Create
  - PUT : Update
  - DELETE : Delete

### 장점

- HTTP Method를 그대로 사용해 별도의 인프라가 필요하지 않음
- 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있음.
- 멀티 플랫폼에 대한 지원 가능

### 단점

- 표준이 존재하지 않음
- HTTP Method 형태가 제한적이다.

----

## 응답 상태 코드

### 1XX

- 전송 프로토콜 수준의 정보 교환

### 2XX

- 클라이언트 요청이 성공적으로 수행됨.
- 200 : OK
- 201 : Created

### 3XX

- 리다이렉트

### 4XX

- 잘못된 요청
- 404 : 요청한 페이지가 없음

### 5XX

- 서버 오류

----

## CORS (Cross-Origin Resource Sharing)

다른 도메인에서 실행중인 웹 애플리케이션에서 선택된 자원에 대한 접근 권한을 부여하는 매커니즘. 즉, 다른 출처(도메인, 프로토콜 또는 포트)를 가진 자원을 요청할 때, 웹 프로그램은 cross-origin HTTP 요청을 실행함.

- 서버측에서 Allow-Control-Allow-Origin을 설정해주면 다른 도메인에서도 접근 가능하게 할 수 있다.



요청이 많아지면 뭐부터 살펴봐야하는지?
CORS
Nginx
Token 살아있는 시간?
SDP
Turn server (webRTC 관련 복습)
#CS