# Web

## GET, POST
GET은 가져오는 것이고, POST는 수행하는 것이다.
### GET

- 데이터가 URL 뒤에 붙어 보내진다.
- select 성격을 가진다. 
- POST에 비해 전송할 수 있는 데이터의 양이 적다.

### POST

- 데이터가 body에 담겨 보내진다.
- 서버의 값이나 상태를 바꾸기위해서 사용된다.

----

## 대칭키
A와 B가 서로 같은 키를 가지고 암호화, 복호화 진행

### 장점

- 공개키 방식보다 암호화, 복호화가 간단하여 빠르다.

### 단점

- 대칭키를 공유해야하는데 전달하는 과정에서 해킹의 위험에 노출될 수 있음.

## 공개키
암호화와 복호화에 사용되는 키를 분리한 방식으로 외부에 공개키를 주고 공개키로 암호화 된 문서를 자신의 private key로 복호화.
크게 두 가지로 나뉨
- 공개 키 암호 - 특정한 비밀 키를 가지고 있는 사용자만 내용을 열어볼 수 있음.(편지 넣는 투입구가 있는 우편함)
	- 공개키를 가지고 암호화 개인키를 가지고 복호화
![](Web/IMG_A1483E0656EE-1.jpeg)
- 공개 키 서명 - 특정한 비밀 키로 만들어졌다는 것을 누구나 확인할 수 있음. (인장으로 편재봉투를 봉한 것)
	- 개인키로 암호화 -> 공개키로 복호화
	- 이는 데이터의 보호의 목적보다는 데이터 제공자의 신원 확인이 보장된다는 것에 초점이 맞음.

### 단점

- 암복호화가 매우 복잡하다 (왜? 암호화와 복호화 키가 서로 다르니까)

## 대칭키 & 공개키 통합 암호화 방식
대칭키와 공개키를 적절히 혼합한 암호화 방식으로 SSL의 시초가 되었음.
```
1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하여 B에게 송신
2. B는 암호문을 받아, 자신의 비밀키로 복호화
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄.
4. A는 자신의 대칭키로 암호문을 복호화
5. 이후부터는 대칭키로 암호화 통신
```

## SSL (Secure Socket Layer)
넷스케이프사에서 전자상거래보안을 위해 개발한 암호화 방식으로 통신하는 상대방이 해커가 아닌지 확인하기 위한 알고리즘
```
1. 사이트는 인증기관에 자신의 정보와 공개키를 제출
2. 인증기관이 검토하고 자신의 개인키로 암호화하여 인증서 생성
3. 2번에서 암호화 된 인증서를 사이트로 송신
4. 개인이 브라우저를 통해 사이트에 접속하면, 암호화된 사이트의 정보와 공개키를 사이트로부터 받음
5. 브라우저가 인증기관의 공개키(브라우저에게만 공개됨)로 이를 복호화 하여 사이트의 공개키를 얻음
6. 브라우저가 대칭키를 사이트의 공개키로 암호화하여 사이트로 보냄
7. 사이트는 자신의 개인키로 암호화 된 대칭키를 복호화
8. 이제 개인과 사이트는 대칭키로 통신 가능
```

- - - -

## 웹 서버
- Client의 요청과 접속관리를 주관
- HTTP를 통해 웹 브라우저에서 요청하는 HTML문서나 오브젝트(이미지 파일 등)을 전송해주는 서비스 프로그램 
- ex) apache, nginx

## WAS (Web Application Server)
- 웹 애플리케이션의 사용자가 많아져 웹서버에 과부하(클라이언트마다 각각의 프로세스를 할당)가 걸리기 시작하자 WAS가 등장.
- 실질적인 애플리케이션 실행(비즈니스 로직, DB접근)을 주관
- 클라이언트의 접속관리와 앱 실행을 분리함으로써 여러 클라이언트가 접근해도 비즈니스 로직 처리를 쓰레드로 할 수 있어짐.
- ex) tomcat

----

## JWT (Json Web Token)

Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token

- 토큰 자체를 정보로 사용하는 Self-Contained 방식

### JWT의 구조

JWT는 `Header.Payload.Signature`의 구조로 이루어져 있으며, 각 부분은 json형태가 Base64로 인코딩되어 표현되어있다.

- Header

  - typ와 alg로 이루어짐.

  - typ : 토큰의 타입을 지정
    - Ex) JWT
  - alg : 서명(Signature) 및 토큰 검증에 사용하는 알고리즘 방식 지정
    - Ex) HS256, RSA

- Payload

  - 토큰에서 사용할 정보의 조각들인 Claim이 담겨있다.
  - 각 클래임은 json의 형태인 key-value형태로 다수의 정보를 넣을 수 있다.

- Signature

  - 토큰을 인코딩하거나 유효성 검증을 할때 사용하는 고유한 암호화 코드

### 단점 및 고려사항

- Self-contained : 토큰 자체에 정보를 담고 있어 혹시라도 보안 문제가 생길 수 있음.
- 토큰의 페이로드에 정보가 많아질수록 토큰의 길이가 늘어나 상당한 트래픽이 발생할 수 있음
- stateless : jwt는 상태를 저장하지 않고 한번 만들어지면 제어가 불가능하므로 토큰 만료 시간을 꼭 넣어주어야함.

----

## REST

- "Representational State Transfer"의 약자

- 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미

- 즉, 자원(resource)의 표현(representation)에 의한 상태 전달

  - 자원 : 해당 프로그램이 관리하는 모든 것
  - 자원의 표현 : 그 자원을 표현하기 위한 이름

  - 상태 전달 
    - 데이터가 요청되어지는 시점에서의 자원의 상태를 전달
    - 보통 JSON 혹은 XML을 통해 주고 받음.

- HTTP Method를 통해 자원에 대한 CRUD를 적용

  - GET : Read
  - POST : Create
  - PUT : Update
  - DELETE : Delete

### 특징

- Uniform Interface
  - URI로 지정한 리소스에 대해 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍쳐 스타일
- stateless
  - 서버가 어떠한 작업을 위한 상태 정보를 보관하지 않기때문에 서버는 들어오는 요청을 처리하기만하면 되기때문에 부담이 덜해짐. 또한 서비스의 자유도도 높아지고 구현이 간단해짐.
- Cacheable
  - HTTP가 웹 표준을 그대로 사용하기 때문에 캐싱기능을 활용할 수 있음
- Self-descriptiveness (자체 표현 구조)
  - REST API의 메시지만 보고도 무엇을 의도하는지 쉽게 이해할 수 있음
- Client - Server 구조
- 계층형 구조
  - REST 서버는 다중 계층으로 구성될 수 있어 보안, 로드밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있으며, Proxy, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게한다.

### 장점

- HTTP Method를 그대로 사용해 별도의 인프라가 필요하지 않음
- 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있음.
- 멀티 플랫폼에 대한 지원 가능

### 단점

- 표준이 존재하지 않음
- HTTP Method 형태가 제한적이다.

----

## 응답 상태 코드

### 1XX

- 전송 프로토콜 수준의 정보 교환

### 2XX

- 클라이언트 요청이 성공적으로 수행됨.
- 200 : OK
- 201 : Created

### 3XX

- 리다이렉트

### 4XX

- 잘못된 요청
- 404 : 요청한 페이지가 없음

### 5XX

- 서버 오류

----

## CORS (Cross-Origin Resource Sharing)

다른 도메인에서 실행중인 웹 애플리케이션에서 선택된 자원에 대한 접근 권한을 부여하는 매커니즘. 즉, 다른 출처(도메인, 프로토콜 또는 포트)를 가진 자원을 요청할 때, 웹 프로그램은 cross-origin HTTP 요청을 실행함.

- 서버측에서 Allow-Control-Allow-Origin을 설정해주면 다른 도메인에서도 접근 가능하게 할 수 있다.

----

## Nginx vs Apache

### Apache

요청 하나 당 하나의 프로세스 또는 스레드가 처리하는 구조이다.

- 요청이 많아지면 CPU와 memory의 사용이 증가하여 성능 저하가 있을 수 있다.
- 아파치 서버 프로세스가 blocking 상태이면 아무 요청을 처리할 수 없고, 처리가 완료될때까지 대기하는 일이 발생
- MPM (Multi Process Module) prefork 방식과 MPM worker 방식이 존자
  - prefork : 각각의 프로세스 할당
  - worker : 프로세스와 스레드를 병행하여 사용

### Nginx

보안과 속도를 최적화시키려는 노력에서 탄생한 웹서버로, 사용이 쉽고 규모가 작으며 정적 데이터 처리가 많은 서비스에 적합하다.

- 프로그램의 흐름이 이벤트에 의해 결정이 되는 Event Driven 방식
  - 기본적으로 싱글 프로세스 기반으로 이벤트를 받는 reactor와 이벤트를 실제 처리하는 worker로 전달하기 위한 handler등으로 구성
- 적은 수의 스레드로 효율적인 일을 처리 -> context switching 비용이 적고 CPU 소모도 적다.
- 길고 많은 I/O처리가 필요한 작업의 경우 시스템 큐에 요청이 쌓여 성능이 저하될 가능성이 있음

----

## 프락시

웹 프락시 서버는 클라이언트와 서버 사이에 위치하여 그들 사이의 HTTP 메시지를 정리하는 중개자이다. 게이트웨이와 반대로 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결함. 

### 왜 프락시를 사용하는가?

- 보안 개선
- 성능 상승
- 비용 절약

### 프락시의 사용 예

- 성인 콘텐츠 차단
- 문서 접근 제어자
- 보안 방화벽
- 웹 캐시
- 콘텐츠 라우터
- 트랜스 코더 (ex 모바일과 pc에 다른 리소스 전송)
- 익명화 프락시 
  - 신원을 식별할 수 있는 특성들(클라이언트 IP주소, From헤더, Referer헤더, 쿠키, URI 세션아이디)을 적극적으로 제거 -> 개인 정보 보호와 익명성 보장

### Forward Proxy

포워드 프록시는 클라이언트와 서버 사이에서 클라이언트의 요청을 받고 대신 서버에게 결과를 받고 그 결과를 클라이언트에게 전달해주는 역할을 함.

- 대개 캐싱 기능이 있고 정해진 사이트만 연결하게 설정하는 등 웹 사용 환경을 제한할 수 있어 기업에서 내부망으로 많이 사용함.

### Reverse Proxy

클라이언트가 웹 서비스에 요청한 데이터를 Reverse Proxy가 받고 클라이언트에게 전달한다. 이렇게 사용하는 이유는 보안적인 이유가 가장 큼.

- 내부 서버 WAS에 직접적으로 접근을 한다면 DB에 접근이 가능하므로 보안에 취약함.
- 또한 내부 서버에 대한 설정으로 로드 밸런싱이나 확장 등에 유리하다.

### Forward와 Reverse의 차이점

- End Point
  - Forward Proxy는 클라이언트가 요청하는 End Point가 실제 서버 도메인
  - Reverse Proxy는 클라이언트가 요청하는 End Point가 프록시 서버의 도메인
- 감춰지는 대상
  - Forward Proxy는  클라이언트가 감춰진다.
    - 요청받는 서버는 프록시 서버를 통해 요청을 받으므로 클라이언트의 정보를 알 수 없음.
  - Reverse Proxy는 서버가 감춰진다.
    - 클라이언트는 리버스 프록시 서버에게 요청하기 때문에 실제 서버의 정보를 알 수가 없다.







----

## 게이트웨이

케이트 웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결해주는 역할. 즉, 프로토콜 변환기처럼 동작.

요청이 많아지면 뭐부터 살펴봐야하는지?
Nginx
Token 살아있는 시간?
SDP
Turn server (webRTC 관련 복습)
#CS