# 프로그래밍 통합
## parameter vs argument
- parameter : 함수를 정의할 때 입력받는 형식을 지정
- argument : 함수를 호출할 때 parameter와 같은 형식으로 넘겨주는 값

## Call by value, call by reference
- Call by value (값에 의한 호출)
	- 인자로 받은 값을 복사하여 처리.
	- 원래의 값이 보존되어 안전하다.
	- 메모리 사용량이 늘어난다.
- call by reference (참조에 의한 호출)
	- 인자로 받은 값의 주소를 참조하여 처리
	- 복사를 하지 않아 빠르다.
	- 원래의 값에 바로 접근하여 원하지 않는 수정이 발생할 수 있음.

----

## 함수형

#### 순수함수
- 동일한 입력에는 항상 같은 값을 반환
- 함수의 실행은 프로그램의 실행에 영향을 미치지 않아야함 (side effect가 없어야함)

----

## MVC

Model : 애플리케이션의 정보, 데이터를 나타냄. (DB, 상수, 초기화값, 변수등)
	- 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야함.
View : 데이터 및 객체의 입력과 보여주는 출력을 담당. 즉, 데이타를 기반으로 사용자들이 볼 수 있는 화면이라 할 수 있음.
	- 모델이 가지고 있는 정보를 따로 저장해서는 안됨.
Controller : 데이터와 사용자 인터페이스 요소들을 잇는 다리 역할. 즉, 사용자가 데이터를 클릭히고 수정하는 것에 대한 ‘이벤트’들을 처리하는 부분을 뜻함.
	- 모델이나 뷰의 변경을 모니터링 해야한다.

사용하는 이유
- 각자의 역할을 담당하여 처리해 효율적이다.
- 유지보수, 확장성, 변경에 대한 유연성이 증가하고 중복도 제거할 수 있다.

----

## 해시

특정 값을 해시함수를 돌려 더 짧은 길이의 값이나 키 또는 주소값으로 변환하는 것이다.

## 해시 충돌
입력값이 다른데 해시 함수의 결과가 같은 경우 해시 충돌이 일어났다고 한다.
- 해시함수의 입력값은 무한하지만 출력값은 유한하므로 비둘기집의 원리로 인해 충돌은 피할 수 없다. -> 해시함수를 잘 작성해야한다.
- 해시함수에서 곱하는 수는 소수를 사용하는 것이 좋다. 2의 승수 - 1 가장 좋아 31을 전통적으로 많이 사용함. -> 소수를 사용할 경우 해시 충돌이 적게 발생.

해결법
- 체이닝(Chaining)
	- 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
장점
- 연결리스트만 사용하므로 복잡한 계산식이 필요없다.
- Lookup 성능 저하가 Linear하다.

- 개방주소법(Open Addressing)
	- 해시 충돌이 발생하면 다른 버켓에 데이터를 삽입하는 방식
		- 선형 탐색 : 다음 버켓 or 몇 개를 건너뛰어 데이터를 삽입
		- 제곱 탐색 : 제곱만큼 건너뛴 버켓에 데이터를 삽입
		- 이중 해시 : 다른 해시 함수를 한번 더 적용한 곳에 삽입
장점
- 체이닝에 비해 추가적인 저장공간이 필요하지 않음
- 삼입/삭제 시 오버헤드가 적음
- 저장할 데이터가 적을 때 유리

## 비둘기집 원리
n+1개의 물건을 n개의 상자에 넣을 때, 최소한 한 상자에는 그 물건이 반드시 두개 이상 들어있다는 원리

----

## 테스팅

	### 면접관이 평가하는 것

- 큰 그림을 그릴 줄 아는가
  - 소프트웨어가 지향하는 바를 정말로 이해하는가?
  - 테스트 케이스 간의 우선 순위를 적절히 매길 수 있는가?

- 조직화
  - 범주를 나눈 다음 테스트를 만들어간다. 
  - Ex) 카메라 -> 사진 촬영, 이미지 관리, 설정 등의 범주

### 예시

- 질문 : 클립을 테스트해라!

1. 사용자는 누구인가? 사용 목적은? -> 질문을 던져라.

   - 선생님들이 종이를 묶어 두기 위해 사용한다.

2. 어떤 유즈케이스가 있나?

   - 종이 다발을 망가뜨리지 않고 함께 묶어 놓는다.

3. 한계 조건을 질문

   - 한 번에 30장까지 묶을 수 있다.

4. 스트레스 조건과 장애 조건은?

5. 테스트는 어떻게 수행할 것인지 생각

   - 정상적으로 사용한다는 것이 어떤의미인지 정의

   - 의자가 5년동안 멀쩡한지를 테스트하는 것보다 일년에 몇번까지 앉을 수 있는지를 테스트

### 함수테스트

- 테스트 케이스 정의
  - 정상적인 케이스
  - 극단적인 케이스 (빈 배열이나 아주 큰 배열과 같은 입력)
  - null, 잘못된 입력 케이스
  - 특수한 입력 (정렬의 경우 이미 정렬된 배열의 입력)

----

## TDD (Test-Driven-Development)

테스트를 먼저 작성하고 테스트를 통과하기 위한 코드를 작성하는 개발 방법

- 결정과 피드백 사이의 갭에 대한 인식하는 것, 더 나아가 결정과 피드백 사이의 갭을 조절하기 위한 테크닉

- 결정이란 : 개발을 하다보면 '이 방법으로 해야지', '이 부분은 이걸 이용해서 짜야지'라는 것을 결정한다.
- 피드백이란 : 개발을 하면서 성공/실패라는 피드백을 얻을 수 있음

- 결정과 피드백의 갭이 클수록 좋지 않음.

장점

- 결함이 줄어든다.
- 코드의 복잡도가 떨어지고 유지보수 비용이 작아질 수 있다.

단점

- 테스트 코드도 작성을 해야하므로 개발 시간이 늘어난다.

----

## API (Application Programming Interface)

데이터와 기능의 집합을 제공하여 컴퓨터와 프로그램간 상호작용을 촉진하며, 서로 정보를 교환 가능하도록 하는 것.

- 하나의 프로그램에서 다른 프로그램의 기능을 쓰기 위해 어떠한 인터페이스를 통해 이용하는 것과 같이 프로그램간의 커뮤니케이션을 담당하는 인터페이스

----

## MSA

"하나의 큰 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐"

### Monolith vs Microservices

#### Monolith

장점

- 소규모 프로젝트에 적합
- 유지보수가 용이

단점

- 서비스/프로젝트가 커질수록 영향도 파악 및 전체 시스템 구조의 파악이 어려움
- 빌드, 테스트, 배포시간이 기하급수적으로 늘어남.
- 서비스를 부분적으로 늘리는 scale-out이 어려움
- 부분의 장애가 전체 서비스의 장애로 이어짐 (single point of failuer)

#### Microservices

특징

- 각각의 서비스는 크기가 작을 뿐, 서비스 자체는 하나의 모놀리틱 아키텍쳐와 유사한 구조를 가짐
- 각각의 서비스는 독립적으로 배포가 가능해야함.
- 각각의 서비스는 다른 서비스에 대한 의존성이 최소화 되어야함.
- 각 서비스는 개별 프로세스로 구동되며, REST와 같은 가벼운 방식으로 통싱되어야 한다.

장점

- 서비스 별 독립적으로 배포 가능 
  - 배포 시 전체 서비스의 중단 없이 가능
  - 요구사항을 신속하게 반영하여 빠르게 배포 가능

- 특정 서비스에 대한 확정성이 용이 (scale-out)
  - 클라우드 사용에 적합한 아키텍쳐 

- 장애가 전체 서비스로 확장될 가능성이 적음

단점

- 전체 서비스가 커짐에 따라 복잡도가 기하급수적으로 늘어남.
- 서비스 간 호출 시 API를 사용하여 통신 비용이나 Latency가 있다.
- 서비스가 각기 분리되어 있어 테스트 및 트랜잭션의 복잡도가 증가하고 많은 자원을 필요로 함.
- 데이터가 여러 서비스에 걸쳐 분산되어 한번에 조회가 어렵고 데이터를 관리하기 어렵다.

----

## Blocking I/O, Non-Blocking I/O

### Blocking I/O

호출된 함수가 자신의 작업을 모두 끝낼때까지 제어권을 가지고 있어 호출한 함수가 대기하도록 만든다.

### Non-Blocking I/O

호출된 함수가 바로 return해서 호출한 함수에게 제어권을 주어 다른 일을 할 수 있게함

#CS